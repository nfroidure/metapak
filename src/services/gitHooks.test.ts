import { describe, beforeEach, test, jest, expect } from '@jest/globals';
import { Knifecycle, constant } from 'knifecycle';
import initBuildPackageGitHooks from './gitHooks.js';
import type { ImporterService, LogService } from 'common-services';
import type { FSService } from './fs.js';

describe('buildPackageGitHooks', () => {
  let $;
  const writeFileAsync = jest.fn<FSService['writeFileAsync']>();
  const readFileAsync = jest.fn<FSService['readFileAsync']>();
  const log = jest.fn<LogService>();
  const importer = jest.fn<ImporterService<{ default: any }>>();

  beforeEach(() => {
    writeFileAsync.mockReset();
    readFileAsync.mockReset();
    log.mockReset();
    importer.mockReset();

    $ = new Knifecycle();
    $.register(constant('log', log));
    $.register(constant('PROJECT_DIR', '/home/whoiam/project/dir'));
    $.register(constant('EOL', '\n'));
    $.register(
      constant('fs', {
        readFileAsync: readFileAsync,
        writeFileAsync: writeFileAsync,
      }),
    );
    $.register(constant('importer', importer));
    $.register(
      constant(
        'resolveModule',
        (moduleName) => `/home/whoiam/project/dir/node_modules/${moduleName}`,
      ),
    );
    $.register(initBuildPackageGitHooks);
  });

  test('should work with one module and one config', async () => {
    $.register(constant('ENV', {}));
    $.register(
      constant('GIT_HOOKS_DIR', '/home/whoiam/project/dir/.git/hooks'),
    );

    importer.mockResolvedValueOnce({
      default: (hooks) => {
        hooks['pre-commit'] = hooks['pre-commit'] || [];
        hooks['pre-commit'].push('npm run test && npm run lint || exit 1');
        return hooks;
      },
    });
    importer.mockRejectedValueOnce(new Error('E_ERROR_1'));
    importer.mockResolvedValueOnce({
      default: (hooks) => {
        hooks['pre-commit'] = hooks['pre-commit'] || [];
        hooks['pre-commit'].push('npm run coveralls');
        return hooks;
      },
    });
    importer.mockRejectedValueOnce(new Error('E_ERROR_2'));
    readFileAsync.mockResolvedValueOnce(Buffer.from(''));
    writeFileAsync.mockResolvedValueOnce();

    const { buildPackageGitHooks } = await $.run(['buildPackageGitHooks']);

    await buildPackageGitHooks({}, ['metapak-nfroidure', 'metapak-fantasia'], {
      'metapak-nfroidure': ['_common', 'lol'],
      'metapak-fantasia': ['_common', 'test'],
    });
    expect(importer.mock.calls).toEqual([
      [
        '/home/whoiam/project/dir/node_modules/metapak-nfroidure/src/_common/hooks.js',
      ],
      [
        '/home/whoiam/project/dir/node_modules/metapak-nfroidure/src/lol/hooks.js',
      ],
      [
        '/home/whoiam/project/dir/node_modules/metapak-fantasia/src/_common/hooks.js',
      ],
      [
        '/home/whoiam/project/dir/node_modules/metapak-fantasia/src/test/hooks.js',
      ],
    ]);
    expect(writeFileAsync.mock.calls.map(bufferToText)).toEqual([
      [
        '/home/whoiam/project/dir/.git/hooks/pre-commit',
        '#!/bin/sh\n' +
          '# Automagically generated by metapak, do not change in place.\n' +
          '# Your changes would be loose on the next npm install run.\n' +
          'npm run test && npm run lint || exit 1;\n' +
          'npm run coveralls',
        { mode: 511 },
      ],
    ]);
    expect(log.mock.calls.filter(filterLogs)).toEqual([
      [
        'debug',
        'No hooks found at:',
        '/home/whoiam/project/dir/node_modules/metapak-nfroidure/src/lol/hooks.js',
      ],
      [
        'debug',
        'No hooks found at:',
        '/home/whoiam/project/dir/node_modules/metapak-fantasia/src/test/hooks.js',
      ],
    ]);
  });

  test('should not run on CI', async () => {
    $.register(
      constant('ENV', {
        CI: 1,
      }),
    );
    $.register(
      constant('GIT_HOOKS_DIR', '/home/whoiam/project/dir/.git/hooks'),
    );

    importer.mockResolvedValueOnce({
      default: (hooks) => {
        hooks['pre-commit'] = hooks['pre-commit'] || [];
        hooks['pre-commit'].push('npm run test && npm run lint || exit 1');
        return hooks;
      },
    });
    importer.mockRejectedValueOnce(new Error('E_ERROR_1'));
    importer.mockResolvedValueOnce({
      default: (hooks) => {
        hooks['pre-commit'] = hooks['pre-commit'] || [];
        hooks['pre-commit'].push('npm run coveralls');
        return hooks;
      },
    });
    importer.mockRejectedValueOnce(new Error('E_ERROR_2'));
    readFileAsync.mockResolvedValueOnce(Buffer.from(''));
    writeFileAsync.mockResolvedValueOnce();

    const { buildPackageGitHooks } = await $.run(['buildPackageGitHooks']);
    await buildPackageGitHooks({}, ['metapak-nfroidure', 'metapak-fantasia'], {
      'metapak-nfroidure': ['_common', 'lol'],
      'metapak-fantasia': ['_common', 'test'],
    });
    expect(importer.mock.calls).toEqual([]);
    expect(writeFileAsync.mock.calls).toEqual([]);
    expect(log.mock.calls.filter(filterLogs)).toEqual([]);
  });

  test('should not run on parent git repository', async () => {
    $.register(constant('ENV', {}));
    $.register(constant('GIT_HOOKS_DIR', '/home/whoiam/project/.git/hooks'));

    importer.mockResolvedValueOnce({
      default: (hooks) => {
        hooks['pre-commit'] = hooks['pre-commit'] || [];
        hooks['pre-commit'].push('npm run test && npm run lint || exit 1');
        return hooks;
      },
    });
    importer.mockRejectedValueOnce(new Error('E_ERROR_1'));
    importer.mockResolvedValueOnce({
      default: (hooks) => {
        hooks['pre-commit'] = hooks['pre-commit'] || [];
        hooks['pre-commit'].push('npm run coveralls');
        return hooks;
      },
    });
    importer.mockRejectedValueOnce(new Error('E_ERROR_2'));
    readFileAsync.mockResolvedValueOnce(Buffer.from(''));
    writeFileAsync.mockResolvedValueOnce();

    const { buildPackageGitHooks } = await $.run(['buildPackageGitHooks']);
    await buildPackageGitHooks({}, ['metapak-nfroidure', 'metapak-fantasia'], {
      'metapak-nfroidure': ['_common', 'lol'],
      'metapak-fantasia': ['_common', 'test'],
    });

    expect(importer.mock.calls).toEqual([]);
    expect(writeFileAsync.mock.calls).toEqual([]);
    expect(log.mock.calls.filter(filterLogs)).toEqual([]);
  });
});

function bufferToText(
  call: Parameters<FSService['writeFileAsync']>,
): [string, string, Parameters<FSService['writeFileAsync']>[2]] {
  return [call[0], call[1].toString(), call[2]];
}

function filterLogs(e: Parameters<LogService>) {
  return !e[0].endsWith('-stack');
}
