import path from 'path';
import { autoService } from 'knifecycle';
import { mapConfigsSequentially, identity } from '../libs/utils.js';
import { printStackTrace } from 'yerror';
import type { FSService } from './fs.js';
import type { ImporterService, LogService } from 'common-services';
import type { ResolveModuleService } from './resolveModule.js';
import type { MetapakPackageJson } from './packageConf.js';

export default autoService(initBuildPackageGitHooks);

export type HooksHash = Record<
  | 'applypatch-msg'
  | 'post-update'
  | 'pre-commit'
  | 'pre-rebase'
  | 'commit-msg'
  | 'pre-applypatch'
  | 'prepare-commit-msg'
  | 'update'
  | 'commit-msg'
  | 'pre-commit'
  | 'pre-push',
  string[]
>;
export type GitHooksTransformer = (
  hooks: HooksHash,
  packageConf: MetapakPackageJson,
) => HooksHash;
export type BuildPackageGitHooksService = (
  packageConf: MetapakPackageJson,
  metapakModulesSequence: string[],
  metapakModulesConfigs: Record<string, string[]>,
) => Promise<void>;

async function initBuildPackageGitHooks({
  ENV,
  PROJECT_DIR,
  GIT_HOOKS_DIR,
  fs,
  EOL,
  log,
  importer,
  resolveModule,
}: {
  ENV: Record<string, string>;
  PROJECT_DIR: string;
  GIT_HOOKS_DIR: string;
  fs: FSService;
  EOL: string;
  log: LogService;
  importer: ImporterService<{ default: GitHooksTransformer }>;
  resolveModule: ResolveModuleService;
}): Promise<BuildPackageGitHooksService> {
  return async (
    packageConf: MetapakPackageJson,
    metapakModulesSequence: string[],
    metapakModulesConfigs: Record<string, string[]>,
  ): Promise<void> => {
    // Avoiding CI since it does not make sense
    if (ENV.CI) {
      return;
    }

    // Avoid adding hooks for package that ain't at the git
    // root directory
    if (path.relative(PROJECT_DIR, GIT_HOOKS_DIR).startsWith('..')) {
      return;
    }

    const hooksBuilders = await mapConfigsSequentially(
      metapakModulesSequence,
      metapakModulesConfigs,
      async (
        metapakModuleName: string,
        metapakModuleConfig: string,
      ): Promise<GitHooksTransformer> => {
        const packageHooksPath = path.join(
          resolveModule(metapakModuleName, packageConf),
          'src',
          metapakModuleConfig,
          'hooks.js',
        );
        try {
          return (await importer(packageHooksPath)).default;
        } catch (err) {
          log('debug', 'No hooks found at:', packageHooksPath);
          log('debug-stack', printStackTrace(err));
        }
        return identity as GitHooksTransformer;
      },
    );
    const hooks = await hooksBuilders.reduce(
      (hooks, hooksBuilder) => hooksBuilder(hooks, packageConf),
      {} as HooksHash,
    );

    await Promise.all(
      Object.keys(hooks).map(async (hookName) => {
        const hookContent =
          '#!/bin/sh' +
          EOL +
          '# Automagically generated by metapak, do not change in place.' +
          EOL +
          '# Your changes would be loose on the next npm install run.' +
          EOL +
          hooks[hookName].join(';' + EOL);
        const hookPath = path.join(GIT_HOOKS_DIR, hookName);

        let currentHookContent = '';

        try {
          currentHookContent = (await fs.readFileAsync(hookPath)).toString();
        } catch (err) {
          log('debug', 'No existing hook found:', hookPath);
          log('debug-stack', printStackTrace(err));
        }
        if (currentHookContent !== hookContent) {
          await fs.writeFileAsync(hookPath, Buffer.from(hookContent), {
            mode: 0o777,
          });
        }
      }),
    );
  };
}
