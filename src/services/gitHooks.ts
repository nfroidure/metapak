import path from 'path';
import { autoService } from 'knifecycle';
import { mapConfigsSequentially, identity } from '../libs/utils.js';
import { FSService } from './fs.js';
import { ImporterService, LogService } from 'common-services';
import { ResolveModuleService } from './resolveModule.js';
import { JsonObject } from 'type-fest';
import { printStackTrace } from 'yerror';

export default autoService(initBuildPackageGitHooks);

export type BuildPackageGitHooksService = (
  packageConf: JsonObject,
  metapakModulesSequence: string[],
  metapakModulesConfigs: Record<string, string[]>,
) => Promise<void>;

async function initBuildPackageGitHooks({
  ENV,
  PROJECT_DIR,
  GIT_HOOKS_DIR,
  fs,
  EOL,
  log,
  importer,
  resolveModule,
}: {
  ENV: Record<string, string>;
  PROJECT_DIR: string;
  GIT_HOOKS_DIR: string;
  fs: FSService;
  EOL: string;
  log: LogService;
  importer: ImporterService<any>;
  resolveModule: ResolveModuleService;
}): Promise<BuildPackageGitHooksService> {
  return async (
    packageConf: JsonObject,
    metapakModulesSequence: string[],
    metapakModulesConfigs: Record<string, string[]>,
  ): Promise<void> => {
    // Avoiding CI since it does not make sense
    if (ENV.CI) {
      return Promise.resolve();
    }

    // Avoid adding hooks for package that ain't at the git
    // root directory
    if (path.relative(PROJECT_DIR, GIT_HOOKS_DIR).startsWith('..')) {
      return Promise.resolve();
    }

    await mapConfigsSequentially(
      metapakModulesSequence,
      metapakModulesConfigs,
      async (metapakModuleName: string, metapakModuleConfig: string) => {
        const packageHooksPath = path.join(
          resolveModule(metapakModuleName, packageConf),
          'src',
          metapakModuleConfig,
          'hooks.js',
        );
        try {
          return (await importer(packageHooksPath)).default;
        } catch (err) {
          log('debug', 'No hooks found at:', packageHooksPath);
          log('debug-stack', printStackTrace(err));
        }
        return identity;
      },
    )
      .then((hooksBuilders) => {
        hooksBuilders = hooksBuilders.reduce(
          (hooks, hooksBuilder) => hooksBuilder(hooks, packageConf),
          {},
        );
        return hooksBuilders;
      })
      .then((hooks) =>
        Promise.all(
          Object.keys(hooks).map(async (hookName) => {
            const hookContent =
              '#!/bin/sh' +
              EOL +
              '# Automagically generated by metapak, do not change in place.' +
              EOL +
              '# Your changes would be loose on the next npm install run.' +
              EOL +
              hooks[hookName].join(';' + EOL);
            const hookPath = path.join(GIT_HOOKS_DIR, hookName);

            let currentHookContent = '';

            try {
              currentHookContent = (
                await fs.readFileAsync(hookPath)
              ).toString();
            } catch (err) {
              log('debug', 'No existing hook found:', hookPath);
              log('debug-stack', printStackTrace(err));
            }
            if (currentHookContent !== hookContent) {
              await fs.writeFileAsync(hookPath, Buffer.from(hookContent), {
                mode: 0o777,
              });
            }
          }),
        ),
      );
  };
}
